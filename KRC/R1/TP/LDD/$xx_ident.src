&ACCESS RO1
&REL 23
&COMMENT LDD package (KSS 8.6.7 or higher)
&PARAM DISKPATH = KRC:\R1\TP\LDD
DEF $XX_IDENT( )
; FOLD SYSTEM-PROGRAMM .... NIEMALS AENDERN!
; ENDFOLD 
; FOLD Deklarationen ;%{H} % Initialisierung 
INT ERG, AXIS_NO, I
DECL E6AXIS IDENT_START  
DECL E6AXIS IDENT_START_M
DECL KRLMSG_T LDE_MSG               
DECL KRLMSGOPT_T OPT                
;APP//DECL EKRLMSGTYPE LDE_MSGTYPE        
;APP//DECL KRLMSGPAR_T LDE_PAR[2]         
;APP//DECL KRLMSGPARTYPE_T LDE_PARTYPE[1] 
INT nHandle, nAnswer
INT validPgNo
DECL CHAR LDEText[50]
LDE_MSG={Modul[] " ", Nr 0, Msg_txt[] "%1"}
OPT={VL_Stop TRUE,Clear_P_Reset TRUE,Log_To_DB FALSE}
IF (LDD_IS_RUNNING == TRUE) THEN
   LDD_RESETKRLVAR()
ENDIF
LDD_SETKRLVAR( )
CHECKOPMODE( TRUE )
LDD_OK=FALSE
LDD_SIMULATE=FALSE
IF ((LDD_SILENT==TRUE) AND (LDD_INIT_OK==FALSE)) THEN
   MsgNotify("SilentLDDConfigNotValid", "LoadDataDetermination")
   GOTO IDENT_END
ENDIF
;ENDFOLD ()
;FOLD AKTIVIERUNG, SAK, TESTBEWEGUNG
IF (LDD_SILENT==FALSE) THEN
   WAIT FOR TRUE
ELSE
   WAIT SEC 2.0
ENDIF
$IDENT_STATE=#I_END 
WAIT SEC 1.0
$IDENT_STATE=#I_READY
WAIT SEC 0.1
IF ($IDENT_STATE<>#I_READY) THEN
   GOTO IDENT_END
ENDIF
SETOV( 30 )
IDENT_START = $IDENT_STARTP
IF ($EX_AX_NUM > 0) THEN   
   IDENT_START.E1 = $AXIS_ACT.E1
   IDENT_START.E2 = $AXIS_ACT.E2
   IDENT_START.E3 = $AXIS_ACT.E3
   IDENT_START.E4 = $AXIS_ACT.E4
   IDENT_START.E5 = $AXIS_ACT.E5
   IDENT_START.E6 = $AXIS_ACT.E6
ENDIF
PTP IDENT_START
IF (LDD_SILENT==FALSE) THEN
   WAIT SEC 0.5
   WAIT FOR  TRUE
   WAIT SEC 0.5
ELSE
   WAIT SEC 2.0
ENDIF
IF (LDD_SILENT==FALSE) THEN
   MsgDialog(nAnswer, "TestRunBeforeMeas", "LoadDataDetermination", "gg", "End", "NoAnswer", "YesAnswer", , , ,)
ELSE
   nAnswer = LDD_TEST
ENDIF
ERG=nAnswer
SWITCH ERG
CASE 1,5
   FOR I=1 TO 10
     SETOV( 10 )
   	 IDENT_START = $IDENT_STARTP	
   	 IF ($EX_AX_NUM > 0) THEN   
        IDENT_START.E1 = $AXIS_ACT.E1
      	IDENT_START.E2 = $AXIS_ACT.E2
      	IDENT_START.E3 = $AXIS_ACT.E3
      	IDENT_START.E4 = $AXIS_ACT.E4
      	IDENT_START.E5 = $AXIS_ACT.E5
      	IDENT_START.E6 = $AXIS_ACT.E6
   	 ENDIF
   	 PTP IDENT_START
   	 WAIT SEC 0.5
     SETOV( 10 )
   ENDFOR	
   SETOV( 30 )
   $IDENT_STATE=#I_TEST
   IF ($IDENT_STATE<>#I_TEST) THEN
      GOTO IDENT_END
   ENDIF
   PTP_REL{A6 -0.001}
   WHILE  ($IDENT_STATE==#I_TEST)
      WAIT SEC 0.1
   ENDWHILE
   WAIT SEC 0.2
CASE 0,6
DEFAULT ;CASE -1,7
   LDD_SIMULATE = TRUE
   GOTO IDENT_END
ENDSWITCH
;ENDFOLD (AKTIVIERUNG, SAK, TESTBEWEGUNG)
;FOLD MESSFAHRTEN, BERECHNUNGEN
IF ($EX_AX_NUM > 0) THEN   
   IDENT_START.E1 = $AXIS_ACT.E1
   IDENT_START.E2 = $AXIS_ACT.E2
   IDENT_START.E3 = $AXIS_ACT.E3
   IDENT_START.E4 = $AXIS_ACT.E4
   IDENT_START.E5 = $AXIS_ACT.E5
   IDENT_START.E6 = $AXIS_ACT.E6
ENDIF
; Messfahrt Trajektorie 1
REPEAT
   IF (LDD_SILENT==FALSE) THEN
      WAIT FOR TRUE
   ELSE
      WAIT SEC 2.0
   ENDIF
   IF (LDD_SILENT==FALSE) THEN
      MsgDialog(nAnswer, "StartMeasRun", "LoadDataDetermination", , "OK", , , , , , )
   ENDIF
   SETOV( 30 )
   PTP IDENT_START
   SETOV( 100 )
   WAIT SEC 0.5
   IF (LDD_SILENT==FALSE) THEN
      WAIT FOR TRUE
   ELSE
      WAIT SEC 2.0
   ENDIF
   CHECKOV100(  )
   $IDENT_STATE=#I_MEAS
   CHECKOPMODE(  )
   IF ($OV_PRO < 100) THEN
      IF (LDD_SILENT==FALSE) THEN
         WAIT FOR TRUE
      ELSE
         WAIT SEC 2.0
      ENDIF
      WAIT SEC 0.5
      MsgNotify("MeasIn100", "LoadDataDetermination")
      WAIT SEC 0.5
      GOTO IDENT_END
   ENDIF
   IF (($IDENT_STATE<>#I_TEST) AND ($IDENT_STATE<>#I_MEAS)) THEN
      GOTO IDENT_END
   ENDIF
   PTP_REL{A6 -0.001}
   WHILE  (($IDENT_STATE==#I_TEST) OR ($IDENT_STATE==#I_MEAS))
      WAIT SEC 0.1
   ENDWHILE
   WAIT SEC 0.2
   IF ($IDENT_STATE==#I_END) THEN
      GOTO IDENT_END
   ENDIF
UNTIL ($IDENT_STATE==#I_MEAS_OK)
$IDENT_STATE=#I_CALC
WAIT SEC 2.0
IF ($IDENT_STATE==#I_END) THEN
   GOTO IDENT_END
ENDIF
IF (LDD_SILENT==FALSE) THEN
   WAIT FOR TRUE
ELSE
   WAIT SEC 2.0
ENDIF
$IDENT_STATE=#I_READY
WAIT SEC 0.1
IF ($IDENT_STATE<>#I_READY) THEN
   GOTO IDENT_END
ENDIF
; Startpunkte fuer Trajektorie 2
IDENT_START_M = $IDENT_STARTP
IDENT_START   = $IDENT_STARTP
IF ($EX_AX_NUM > 0) THEN   
   IDENT_START.E1  = $AXIS_ACT.E1
   IDENT_START.E2  = $AXIS_ACT.E2
   IDENT_START.E3  = $AXIS_ACT.E3
   IDENT_START.E4  = $AXIS_ACT.E4
   IDENT_START.E5  = $AXIS_ACT.E5
   IDENT_START.E6  = $AXIS_ACT.E6
   IDENT_START_M.E1 = $AXIS_ACT.E1
   IDENT_START_M.E2 = $AXIS_ACT.E2
   IDENT_START_M.E3 = $AXIS_ACT.E3
   IDENT_START_M.E4 = $AXIS_ACT.E4
   IDENT_START_M.E5 = $AXIS_ACT.E5
   IDENT_START_M.E6 = $AXIS_ACT.E6
ENDIF
; Messfahrt Trajektorie 2
REPEAT
   IF (LDD_SILENT==FALSE) THEN
      WAIT FOR TRUE
   ELSE
      WAIT SEC 2.0
   ENDIF
   WAIT SEC 0.5
   IF (LDD_SILENT==FALSE) THEN
      MsgDialog(nAnswer, "GoToMeasRun2", "LoadDataDetermination", , "OK", , , , , ,)
   ENDIF
   SETOV( 30 )
   PTP IDENT_START_M
   PTP IDENT_START
   SETOV( 100 )
   IF (LDD_SILENT==FALSE) THEN
      WAIT FOR TRUE
   ELSE
      WAIT SEC 2.0
   ENDIF
   CHECKOV100(  )
   $IDENT_STATE=#I_MEAS
   CHECKOPMODE(  )
   IF ($OV_PRO < 100) THEN
      IF (LDD_SILENT==FALSE) THEN
         WAIT FOR TRUE
      ELSE
         WAIT SEC 2.0
      ENDIF
      WAIT SEC 0.5
      MsgNotify("MeasIn100", "LoadDataDetermination")
      WAIT SEC 0.5
      GOTO IDENT_END
   ENDIF   
   IF (($IDENT_STATE<>#I_TEST) AND ($IDENT_STATE<>#I_MEAS)) THEN
      GOTO IDENT_END
   ENDIF
   PTP_REL{A6 -0.001}
   WHILE  (($IDENT_STATE==#I_TEST) OR ($IDENT_STATE==#I_MEAS))
      WAIT SEC 0.1
   ENDWHILE
   WAIT SEC 0.2
   IF ($IDENT_STATE==#I_END) THEN
      GOTO IDENT_END
   ENDIF
UNTIL ($IDENT_STATE==#I_MEAS_OK)
SETOV( 30 )
PTP IDENT_START_M
$IDENT_STATE=#I_CALC
WAIT SEC 0.5
IF ($IDENT_STATE==#I_END) THEN
   GOTO IDENT_END
ENDIF
WAIT SEC 0.5
$IDENT_STATE=#I_READY
WAIT SEC 0.1
IF ($IDENT_STATE<>#I_READY) THEN
   GOTO IDENT_END
ENDIF
; Startpunkte fuer Trajektorie 3
IDENT_START_M = $IDENT_STARTP
IDENT_START   = $IDENT_STARTP
IF ($EX_AX_NUM > 0) THEN   
   IDENT_START.E1  = $AXIS_ACT.E1
   IDENT_START.E2  = $AXIS_ACT.E2
   IDENT_START.E3  = $AXIS_ACT.E3
   IDENT_START.E4  = $AXIS_ACT.E4
   IDENT_START.E5  = $AXIS_ACT.E5
   IDENT_START.E6  = $AXIS_ACT.E6
   IDENT_START_M.E1 = $AXIS_ACT.E1
   IDENT_START_M.E2 = $AXIS_ACT.E2
   IDENT_START_M.E3 = $AXIS_ACT.E3
   IDENT_START_M.E4 = $AXIS_ACT.E4
   IDENT_START_M.E5 = $AXIS_ACT.E5
   IDENT_START_M.E6 = $AXIS_ACT.E6
ENDIF
; Messfahrt Trajektorie 3
REPEAT 
   IF (LDD_SILENT==FALSE) THEN
      WAIT FOR TRUE
   ELSE
      WAIT SEC 2.0
   ENDIF
   IF (LDD_SILENT==FALSE) THEN
      MsgDialog(nAnswer, "GoToMeasRun3", "LoadDataDetermination", , "OK", , , , , , )
   ENDIF
   WAIT SEC 0.5
   SETOV( 30 )
   PTP IDENT_START_M
   PTP IDENT_START
   SETOV( 100 )
   IF (LDD_SILENT==FALSE) THEN
      WAIT FOR TRUE
   ELSE
      WAIT SEC 2.0
   ENDIF
   CHECKOV100(  )
   $IDENT_STATE=#I_MEAS
   CHECKOPMODE(  )
   IF ($OV_PRO < 100) THEN
      IF (LDD_SILENT==FALSE) THEN
         WAIT FOR TRUE
      ELSE
         WAIT SEC 2.0
      ENDIF
      WAIT SEC 0.5
      MsgNotify("MeasIn100", "LoadDataDetermination")
      WAIT SEC 0.5
      GOTO IDENT_END
   ENDIF  
   IF (($IDENT_STATE<>#I_TEST) AND ($IDENT_STATE<>#I_MEAS)) THEN
      GOTO IDENT_END
   ENDIF
   PTP_REL{A6 -0.001}
   WHILE  (($IDENT_STATE==#I_TEST) OR ($IDENT_STATE==#I_MEAS))
   WAIT SEC 0.1
   ENDWHILE
   WAIT SEC 0.2
   IF ($IDENT_STATE==#I_END) THEN
      GOTO IDENT_END
   ENDIF
UNTIL ($IDENT_STATE==#I_MEAS_OK)
$IDENT_STATE=#I_CALC
WAIT SEC 0.5
IF ($IDENT_STATE==#I_END) THEN
   GOTO IDENT_END
ENDIF
;ENDFOLD (MESSFAHRTEN, BERECHNUNGEN)
;FOLD FAHRT ZUM AUSGANGSPUNKT
IDENT_START = $IDENT_STARTP
IF ($EX_AX_NUM > 0) THEN   
   IDENT_START.E1 = $AXIS_ACT.E1
   IDENT_START.E2 = $AXIS_ACT.E2
   IDENT_START.E3 = $AXIS_ACT.E3
   IDENT_START.E4 = $AXIS_ACT.E4
   IDENT_START.E5 = $AXIS_ACT.E5
   IDENT_START.E6 = $AXIS_ACT.E6
   IDENT_START_M.E1 = $AXIS_ACT.E1
   IDENT_START_M.E2 = $AXIS_ACT.E2
   IDENT_START_M.E3 = $AXIS_ACT.E3
   IDENT_START_M.E4 = $AXIS_ACT.E4
   IDENT_START_M.E5 = $AXIS_ACT.E5
   IDENT_START_M.E6 = $AXIS_ACT.E6
ENDIF
IF (LDD_SILENT==FALSE) THEN
   WAIT FOR TRUE
ELSE
   WAIT SEC 2.0
ENDIF
IF (LDD_SILENT==FALSE) THEN
   MsgDialog(nAnswer, "GoToStart", "LoadDataDetermination", , "OK", , , , , , )
ENDIF
WAIT SEC 0.5
SETOV( 30 )
PTP IDENT_START_M
PTP IDENT_START
SETOV( 100 )
LDD_OK = TRUE
;ENDFOLD (FAHRT ZUM AUSGANGSPUNKT)
;FOLD ENDE
IDENT_END:
LDD_RESETKRLVAR( )
$IDENT_STATE=#I_END
WAIT SEC 2.0
;ENDFOLD (ENDE)
END
;FOLD LDD_SET_AND_RESET_KRLVAR ;%{H}
GLOBAL DEF LDD_SETKRLVAR( )
   INT AXIS_NO
   LDD_IS_RUNNING = TRUE
   LDD_LOAD_SAVE = $LOAD  
   $LOAD.M = $DEF_L_M
   $LOAD.CM = $DEF_L_CM
   $LOAD.J = $DEF_L_J
   LDD_LOAD_A3_SAVE = $LOAD_A3  
   $LOAD_A3.M = $DEF_LA3_M
   $LOAD_A3.CM = $DEF_LA3_CM
   $LOAD_A3.J = $DEF_LA3_J
   LDD_SET_KRLVAR_FRAME( 0 )  
   LDD_SET_KRLVAR_FRAME( 1 )  
   FOR AXIS_NO=1 TO  6
      LDD_TORQMON_SAVE[AXIS_NO] = $torqmon[AXIS_NO]  
      $torqmon[AXIS_NO]=200
      IF NOT ( VARSTATE("$VEL_AXIS") == #INITIALIZED ) THEN
         $VEL_AXIS[AXIS_NO]=50
      ENDIF
      LDD_VEL_AXIS_SAVE[AXIS_NO] = $VEL_AXIS[AXIS_NO]  
      $VEL_AXIS[AXIS_NO]=50
      IF NOT ( VARSTATE("$ACC_AXIS") == #INITIALIZED ) THEN
         $ACC_AXIS[AXIS_NO]=25
      ENDIF
      LDD_ACC_AXIS_SAVE[AXIS_NO] = $ACC_AXIS[AXIS_NO]  
      $ACC_AXIS[AXIS_NO]=25
   ENDFOR
   FOR AXIS_NO=1 TO  $EX_AX_NUM
      IF ( VARSTATE("$VEL_EXTAX") == #INITIALIZED ) THEN
         LDD_VEL_EXTAX_SAVE[AXIS_NO] = $VEL_EXTAX[AXIS_NO]
         $VEL_EXTAX[AXIS_NO]=100
      ELSE
         $VEL_EXTAX[AXIS_NO]=100
         LDD_VEL_EXTAX_SAVE[AXIS_NO] = $VEL_EXTAX[AXIS_NO]
      ENDIF
      IF ( VARSTATE("$ACC_EXTAX") == #INITIALIZED ) THEN
         LDD_ACC_EXTAX_SAVE[AXIS_NO] = $ACC_EXTAX[AXIS_NO]
         $ACC_EXTAX[AXIS_NO]=50
      ELSE
         $ACC_EXTAX[AXIS_NO]=50
         LDD_ACC_EXTAX_SAVE[AXIS_NO] = $ACC_EXTAX[AXIS_NO]
      ENDIF      
   ENDFOR
   LDD_SET_KRLVAR_INT( 1, 0 )    
   LDD_SET_KRLVAR_INT( 2, 0 )    
   LDD_SET_KRLVAR_INT( 3, 100 )  
   LDD_TO_BE_RESTORED = TRUE
END
DEF LDD_SET_KRLVAR_FRAME( FLAG :IN )
   INT FLAG
   SWITCH FLAG
   CASE 0 ; $BASE
      IF NOT( VARSTATE("$BASE") == #INITIALIZED ) THEN
         $BASE = $NULLFRAME
      ENDIF
      LDD_BASE_SAVE = $BASE
      $BASE = $NULLFRAME
   CASE 1 ; $TOOL
      IF NOT( VARSTATE("$TOOL") == #INITIALIZED ) THEN
         $TOOL = $NULLFRAME
      ENDIF
      LDD_TOOL_SAVE = $TOOL
      $TOOL = $NULLFRAME
   DEFAULT
   ENDSWITCH
END
DEF LDD_SET_KRLVAR_INT( FLAG :IN, VALUE :IN )
   INT FLAG
   INT VALUE
   SWITCH FLAG
   CASE 1 ; $FILTER
      IF NOT ( VARSTATE("$FILTER") == #INITIALIZED ) THEN
         $FILTER = VALUE
      ENDIF
      LDD_FILTER_SAVE = $FILTER
      $FILTER = VALUE
   CASE 2 ; $ADVANCE
      IF NOT ( VARSTATE("$ADVANCE") == #INITIALIZED ) THEN
         $ADVANCE = VALUE
      ELSE
      ENDIF
      LDD_ADVANCE_SAVE = $ADVANCE
      $ADVANCE = VALUE
   CASE 3 ; $OV_PRO
      IF NOT ( VARSTATE("$OV_PRO") == #INITIALIZED ) THEN
         $OV_PRO = VALUE
      ELSE
      ENDIF
      LDD_OVERRIDE_SAVE = $OV_PRO
      $OV_PRO = VALUE
   DEFAULT
   ENDSWITCH
END
GLOBAL DEF LDD_RESETKRLVAR( )
   INT AXIS_NO
   IF ( LDD_TO_BE_RESTORED == TRUE ) THEN
      $OV_PRO = LDD_OVERRIDE_SAVE
      $FILTER = LDD_FILTER_SAVE
      $ADVANCE = LDD_ADVANCE_SAVE
      FOR AXIS_NO=1 TO  $EX_AX_NUM
         $VEL_EXTAX[AXIS_NO]=LDD_VEL_EXTAX_SAVE[AXIS_NO]
         $ACC_EXTAX[AXIS_NO]=LDD_ACC_EXTAX_SAVE[AXIS_NO]
      ENDFOR
      FOR AXIS_NO=1 TO  6
         $torqmon[AXIS_NO] = LDD_TORQMON_SAVE[AXIS_NO]
         $VEL_AXIS[AXIS_NO] = LDD_VEL_AXIS_SAVE[AXIS_NO]
         $ACC_AXIS[AXIS_NO] = LDD_ACC_AXIS_SAVE[AXIS_NO]
      ENDFOR
      $BASE = LDD_BASE_SAVE
      $TOOL = LDD_TOOL_SAVE
      LDD_TO_BE_RESTORED = FALSE
   ENDIF
   LDD_IS_RUNNING = FALSE
END
;ENDFOLD (SET_AND_RESET_KRLVAR)
;FOLD SETOV ;%{H}
DEF SETOV( NEWOV :IN )
   INT NEWOV
   IF NOT ( VARSTATE("NEWOV") == #INITIALIZED ) THEN
      NEWOV = 10
   ENDIF
   IF ( $MODE_OP == #T1 ) THEN
      $OV_PRO = 100
   ELSE
      $OV_PRO = NEWOV
   ENDIF
END
;ENDFOLD (SETOV)
;FOLD CHECKOV100 ;%{H}
DEF CHECKOV100(  )
   IF ( $OV_PRO < 100 ) THEN
      WAIT SEC 0.5
      MsgQuit("OVNot100", "LoadDataDetermination")
      WHILE  $OV_PRO < 100
         WAIT SEC 0.5
      ENDWHILE
      WAIT SEC 0.5
   ENDIF
END
;ENDFOLD (CHECKOV100)
;FOLD CHECKOPMODE ;%{H}
DEF CHECKOPMODE( FIRSTCALL :IN )
   BOOL FIRSTCALL
   IF NOT ( VARSTATE("FIRSTCALL") == #INITIALIZED ) THEN
      FIRSTCALL = FALSE
   ENDIF
   IF ($MODE_OP == #T1) THEN
      WAIT SEC 0.5
      IF ( FIRSTCALL == TRUE ) THEN
         MsgQuit("LdeNotInT1", "LoadDataDetermination")
      ELSE
         MsgQuit("MeasNotInT1", "LoadDataDetermination")
      ENDIF
      WHILE  $MODE_OP == #T1
         WAIT SEC 0.5
      ENDWHILE
      WAIT SEC 0.5
   ENDIF
END
;ENDFOLD (CHECKOPMODE)
